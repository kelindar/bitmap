// Code generated by command: go run amd64.go -out ../simd_amd64.s -stubs ../simd_amd64.go -pkg=bitmap. DO NOT EDIT.

// +build !appengine
// +build !noasm
// +build gc

#include "textflag.h"

// func x64count(a []uint64) uint64
// Requires: POPCNT
TEXT ·x64count(SB), NOSPLIT, $0-32
	MOVQ a_base+0(FP), AX
	MOVQ a_len+8(FP), CX
	XORQ DX, DX

	// perform vectorized operation for every block of 256 bits
body:
	CMPQ CX, $0x00000004
	JL   tail

	// count the bits, 4 numbers at a time
	POPCNTQ (AX), BX
	POPCNTQ 8(AX), SI
	POPCNTQ 16(AX), DI
	POPCNTQ 24(AX), R8
	ADDQ    BX, DX
	ADDQ    SI, DX
	ADDQ    DI, DX
	ADDQ    R8, DX

	// continue the interation by moving read pointers
	ADDQ $0x00000020, AX
	SUBQ $0x00000004, CX
	JMP  body

tail:
	CMPQ    CX, $0x00
	JE      done
	POPCNTQ (AX), R15
	ADDQ    R15, DX

	// continue the interation by moving read pointers
	ADDQ $0x00000008, AX
	SUBQ $0x00000001, CX
	JMP  tail

done:
	MOVQ DX, ret+24(FP)
	RET

// func x64and(a []uint64, b []uint64)
// Requires: AVX, AVX2
TEXT ·x64and(SB), NOSPLIT, $0-48
	MOVQ a_base+0(FP), AX
	MOVQ b_base+24(FP), CX
	MOVQ b_len+32(FP), DX
	XORQ BX, BX

	// perform vectorized operation for every block of 512 bits
body:
	CMPQ DX, $0x00000008
	JL   tail

	// perform the logical "AND" operation
	VMOVUPD (CX), Y0
	VMOVUPD 32(CX), Y1
	VPAND   (AX), Y0, Y0
	VPAND   32(AX), Y1, Y1
	VMOVUPD Y0, (AX)
	VMOVUPD Y1, 32(AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000040, AX
	ADDQ $0x00000040, CX
	SUBQ $0x00000008, DX
	JMP  body

tail:
	CMPQ DX, $0x00
	JE   done

	// perform the logical "AND" operation
	MOVQ (CX), BX
	ANDQ (AX), BX
	MOVQ BX, (AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, CX
	SUBQ $0x00000001, DX
	JMP  tail

done:
	RET

// func x64andn(a []uint64, b []uint64)
// Requires: AVX, AVX2, BMI
TEXT ·x64andn(SB), NOSPLIT, $0-48
	MOVQ a_base+0(FP), AX
	MOVQ b_base+24(FP), CX
	MOVQ b_len+32(FP), DX
	XORQ BX, BX

	// perform vectorized operation for every block of 512 bits
body:
	CMPQ DX, $0x00000008
	JL   tail

	// perform the logical "ANDNOT" operation
	VMOVUPD (CX), Y0
	VMOVUPD 32(CX), Y1
	VPANDN  (AX), Y0, Y0
	VPANDN  32(AX), Y1, Y1
	VMOVUPD Y0, (AX)
	VMOVUPD Y1, 32(AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000040, AX
	ADDQ $0x00000040, CX
	SUBQ $0x00000008, DX
	JMP  body

tail:
	CMPQ DX, $0x00
	JE   done

	// perform the logical "ANDNOT" operation
	MOVQ  (CX), BX
	ANDNQ (AX), BX, BX
	MOVQ  BX, (AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, CX
	SUBQ $0x00000001, DX
	JMP  tail

done:
	RET

// func x64or(a []uint64, b []uint64)
// Requires: AVX, AVX2
TEXT ·x64or(SB), NOSPLIT, $0-48
	MOVQ a_base+0(FP), AX
	MOVQ b_base+24(FP), CX
	MOVQ b_len+32(FP), DX
	XORQ BX, BX

	// perform vectorized operation for every block of 512 bits
body:
	CMPQ DX, $0x00000008
	JL   tail

	// perform the logical "OR" operation
	VMOVUPD (CX), Y0
	VMOVUPD 32(CX), Y1
	VPOR    (AX), Y0, Y0
	VPOR    32(AX), Y1, Y1
	VMOVUPD Y0, (AX)
	VMOVUPD Y1, 32(AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000040, AX
	ADDQ $0x00000040, CX
	SUBQ $0x00000008, DX
	JMP  body

tail:
	CMPQ DX, $0x00
	JE   done

	// perform the logical "OR" operation
	MOVQ (CX), BX
	ORQ  (AX), BX
	MOVQ BX, (AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, CX
	SUBQ $0x00000001, DX
	JMP  tail

done:
	RET

// func x64xor(a []uint64, b []uint64)
// Requires: AVX, AVX2
TEXT ·x64xor(SB), NOSPLIT, $0-48
	MOVQ a_base+0(FP), AX
	MOVQ b_base+24(FP), CX
	MOVQ b_len+32(FP), DX
	XORQ BX, BX

	// perform vectorized operation for every block of 512 bits
body:
	CMPQ DX, $0x00000008
	JL   tail

	// perform the logical "XOR" operation
	VMOVUPD (CX), Y0
	VMOVUPD 32(CX), Y1
	VPXOR   (AX), Y0, Y0
	VPXOR   32(AX), Y1, Y1
	VMOVUPD Y0, (AX)
	VMOVUPD Y1, 32(AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000040, AX
	ADDQ $0x00000040, CX
	SUBQ $0x00000008, DX
	JMP  body

tail:
	CMPQ DX, $0x00
	JE   done

	// perform the logical "XOR" operation
	MOVQ (CX), BX
	XORQ (AX), BX
	MOVQ BX, (AX)

	// continue the interation by moving read pointers
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, CX
	SUBQ $0x00000001, DX
	JMP  tail

done:
	RET
